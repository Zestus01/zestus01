## Week 7, third week of in person.

### To pseudocode or not to pseudocode that is the question. A question that has only one answer. To pseudocode is to think, something that is in low amount these days, especially from this author. It is a rare occasion that I think about things, but when I do I make an artificial "intelligence" to play Tic-Tac-Toe. I say "intelligence" because the AI couldn't pass a Turing test to save it's own fake life. One of the few, starting to become many, cases where pseudocoding is extremely helpful.  

### Step one in pseudocoding is figuring out the problem. In this case the overarching problem was how to decide the best move in Tic-Tac-Toe. Statistically the best first move in Tic-Tac-Toe is to place in a corner, second move is to be in the middle. After the initial moves from both players the best move is to set up a potential win and otherwise block. Break this down even more into the base question "How to see a potential win." Seems a semi difficult question, but finding an "actual win" isn't much different. Whichever move after placing a mark is one away from a win, boom potential win. First step of pseodocoding done, now to think about the solution.

### Step two is thinking of the solution. How am I going to implement the solution to the problem that I found to be the root problem. The solution needs to be broken down in just the same way as the problem. Into the base steps and as generic as you can get it. Finding the winner in Tic-Tac-Toe can be broken down into "How to check each square of the grid" and "How to get the value, either O or X, of a square". Stepping up from this to how to check for a potential win is to keep track of how many like marked squares are in each win condition. The condition with the most like marked squares is the best potential win. If you can't win with a move in Tic-Tac-Toe you need to stop your opponent from winning. This uses the same exact logic, just flipped on it's head. 

### Step three in pseudocode is to start thinking in the code paradigm. How to implement the solution in whatever language is in the tech-stack. "How am I going to check each square" in code. Solve the lowest step pseudocoded, then upon that solution solve the problem one step higher. Each solution will eventually lead to solving the overarching problem and to designing a basic AI to play Tic-Tac-Toe. Can't climb a mountain? Make that mountain into a bunch of mole hills and bulldoze them down. 